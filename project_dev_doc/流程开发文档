
核心流程规划

遗留的需要优化的问题：
1、后端数据库需要同步链上数据及分布式存储数据。加载数据库中如果没有数据，需要对链上及分布式存在中也加载一遍，并保存到数据库。
	目前采用最简单的创建时保存到数据库，再加上简单回复机制（没有数据时从连上及分布式存储上加载）
2、私钥保存的方案，尤其是生产环境时需要更加标准科学。（本质上web工程就是个后端产品，私钥保存在项目中就是保存在了后端，基本是安全的，只是可以有更安全的方式）
3、测试链转换为主网时的方案不是很好，目前用的是自建provide，方式不是很标准。并且服务器端（这个已经解决）
4、图片加载需要有话，目前直接从ipfs中加载，这个肯定不行。需要把图片保存到本地或者用更好的云存储方案。

5、作者以钱包地址为准还是以另设ID为准？目前是钱包地址为准。没有另设作者ID，只有笔名。
    并且一个钱包只能注册一个作者账户，这个应该优化一下，让一个钱包可以注册多个作者账户。
6、钱包作为唯一合法凭证，还是有些不够的，要是秘钥被丢失了就没法再拥有笔名和作品了。
   这个需要更加合理的设计及优化。尤其是兼容性这块。
7、在代码中实现一下数据库每天定时备份，并删除3天以上的备份功能。(已经实现)
8、数据库数据遗失导致链上数据没法获得。可以通过另设同步指令来获取到数据库，使数据库数据根据链上数据重建（这好像有点问题，因为没有获取所有相关钱包账号的手段）。
9、如果数据库中的数据被删除了，比如user数据，那么由于数据库与链上数据不同步，就无法加载数据，这个看后面是否需要同步一下。


探索点：
1、作者读者互动创作。创作工具中实现一个AI角色分量分析图谱功能，让作者及读者实时看到各个角色在
作品中所占的分量，可以给作者提供分量调整参考。
2、AI角色体验，用AI来生成故事中角色，用于用户的代币消耗。



1、作者创作流程
    需要完成的核心流程任务：
    作者注册流程完善（1-2天）
    [ ] 测试现有的AuthorManager合约功能
    [ ] 完善作者注册页面的错误处理
    [ ] 添加注册成功后的引导流程
    作品发布流程完善（2-3天）
    [ ] 测试StoryManager合约的发布功能
    [ ] 完善作品编辑器的保存功能
    [ ] 实现IPFS内容存储集成
    [ ] 添加发布状态和进度提示
    阅读功能完善（1-2天）
    [ ] 测试现有的阅读页面功能
    [ ] 确保IPFS内容正确加载
    [ ] 优化阅读体验

    具体执行步骤：
    第一天：作者注册功能测试和完善
    // 需要测试的关键功能
    - 钱包连接状态检查
    - 笔名唯一性验证
    - 作者信息上链
    - 注册成功后的状态更新

    步骤：
        1. 合约功能测试
        笔名验证功能
        测试用例：
        - 空笔名 (应该失败)
        - 过短笔名 (< 2字符，应该失败)
        - 过长笔名 (> 20字符，应该失败)
        - 特殊字符笔名 (应该失败)
        - 重复笔名 (应该失败)
        - 合法笔名 (应该成功)
        作者注册功能
        测试用例：
        - 未连接钱包注册 (应该失败)
        - 已注册作者重复注册 (应该失败)
        - 正常注册流程 (应该成功)
        2. 前端界面测试
            1、钱包连接
            测试未连接钱包时的提示
            测试连接钱包按钮功能
            验证连接状态显示
            2、表单验证
            测试笔名输入框验证规则
            测试简介输入框
            测试邮箱格式验证
            测试类型选择功能
            测试协议同意选项
            3、提交功能
            测试提交按钮状态
            测试提交过程中的加载状态
            测试成功/失败提示
            测试页面跳转
        3. 错误处理测试
            1、合约错误
            测试gas不足情况
            测试网络断开情况
            测试合约调用失败处理
            2、表单错误
            测试输入验证提示
            测试错误状态清除
            测试重试功能

    具体执行步骤：
        1、准备测试环境
            配置环境变量
            # 1. 复制示例环境文件
            cp .env.example .env

            # 2. 在.env文件中配置以下变量：
            BSC_TESTNET_RPC_URL=https://data-seed-prebsc-1-s1.binance.org:8545
            PRIVATE_KEY=你的部署账户私钥
            BSCSCAN_API_KEY=你的BscScan API密钥 # 用于验证合约
        2、准备测试账户
            # 1. 创建测试账户（使用MetaMask）：
            创建测试账户（使用MetaMask）
            创建部署账户（用于部署合约）
                打开 MetaMask 并创建一个新的钱包账户。
                记录下这个账户的地址和私钥。
            创建测试账户A（用于普通作者注册）
                在 MetaMask 中创建另一个账户。
                记录下这个账户的地址和私钥。
            创建测试账户B（用于测试重复注册）
                再次在 MetaMask 中创建一个新账户。
                记录下这个账户的地址和私钥。

            账户1：
            account 0xd61617A8D28258012f242B6C1294Bc2b26DbDce8
            private 42b478d68c9b3ac37857a4d6822d66139a756ee62eee7c2665e7354c315089eb
            账户2：
            account 0xFEe7aD9ad41B542D4f0A8266d4DC4A160eD6BDdC
            private 66fd6d154b29420dcaedc4e24fd0e21f67f3b50a4f1bebb27d6b9ade7d4f4997
            账户3：
            account 0x12167bB3ECeD838AF18539Ca7842Db70d4b58D4E
            private 95399a28cef5e153c12701ca12ac11d5c1ce2f4d2e7bae62d38e55d3e2d479b1


            # 2. 在MetaMask中添加BSC测试网络
            网络名称: BSC Testnet
            RPC URL: https://data-seed-prebsc-1-s1.binance.org:8545
            Chain ID: 97
            货币符号: tBNB
            区块浏览器: https://testnet.bscscan.com

            # 3. 获取BSC测试网BNB
            - 访问 https://testnet.bnbchain.org/faucet-smart
            - 或者使用 https://testnet.binance.org/faucet-smart
            - 为每个测试账户申请测试币（每个账户至少需要0.1 BNB用于测试） 
       
            对于开发和部署来说,BSCSCAN_API_KEY=你的BscScan API密钥这个密钥不是必须的。你可以:
            先删除这一行，只保留必要的配置:
            如果将来需要验证合约，你可以:
            去 BSCScan 注册账号
            创建 API 密钥
            再添加这个配置
       
        3、部署合约到BSC测试网
            # 1. 安装依赖
            npm install

            # 2. 编译合约
            npx hardhat compile

            # 3. 部署合约到BSC测试网
            npx hardhat run scripts/deploy.js --network bscTestnet


            npx hardhat run scripts/deploy-part1.js --network bscTestnet
            npx hardhat run scripts/deploy-part2.js --network bscTestnet
            npx hardhat run scripts/deploy-part3.js --network bscTestnet
            npx hardhat run scripts/deploy-part4.js --network bscTestnet

            部署结果
            npx hardhat run scripts/deploy-part1.js --network bscTestnet
            Deploying contracts with the account: 0xd61617A8D28258012f242B6C1294Bc2b26DbDce8
            Deploying TaforToken...
            TaforToken deployed to: 0x595bEf262261F2545508ED6423c47237C61ACd8C
            Deploying AuthorManager...
            AuthorManager deployed to: 0xe26F72e9f95318c32aE32726af8e6E0659ED24e6
            Contract addresses saved to contract-addresses.json
            Part 1 deployment completed successfully!


            # 4. 保存部署的合约地址到专门的文档中
            合约地址记录：
            - AuthorManager: 0x...
            - StoryManager: 0x...
            - NovelNFT: 0x...

            
        4、验证合约
        # 在BSC测试网上验证合约
        npx hardhat verify --network bscTestnet <合约地址> <构造函数参数>

        npx hardhat verify --network bscTestnet 0xe26F72e9f95318c32aE32726af8e6E0659ED24e6 

        # 例如：
        npx hardhat verify --network bscTestnet 0x合约地址 AuthorManager合约构造函数参数
        
        5、更新前端配置
        // 在apps/web/.env中更新合约地址
     

        // 确保前端配置使用了BSC测试网
        // 检查 apps/web/config/chains.ts 中是否正确配置了BSC测试网

        6、准备测试数据和记录文档
        # 创建测试记录文档，记录以下信息：
        1. 部署账户地址：0x...
        2. 测试账户A地址：0x...
        3. 测试账户B地址：0x...
        4. 已部署的合约地址列表
        5. 测试用例清单


// 确保前端配置使用了BSC测试网
// 检查 apps/web/config/chains.ts 中是否正确配置了BSC测试网

章节内容映射方案
后台服务器 + 固定ID 方案实现
链上存储：
    作品ID（可以是UUID或自增ID）
    作品基本元数据（标题、作者等）
    不存储CID
后台服务器：
    数据库中增加一个作品ID到各个章节的CID的映射model
    处理内容更新并上传到IPFS
    提供API接口供前端获取最新CID
前端应用：
    从区块链获取作品ID
    从后台服务器获取对应的最新CID
    使用CID从IPFS获取内容
工作流程
创建新作品：
    在区块链上创建作品记录，获取作品ID
    生成初始内容并上传到IPFS，获取CID
    在后台服务器记录作品ID和CID的映射
更新内容：
    获取当前内容，进行修改
    上传新内容到IPFS，获取新CID
    在后台服务器更新作品ID到CID的映射
读取内容：
    从区块链获取作品ID
    从后台服务器获取最新CID
    使用CID从IPFS获取内容


前端与合约验证流程：
1、AuthorManager 合约功能验证：
    A. 作者注册功能
    - 注册新作者（registerAuthor）
    * 验证笔名长度（1-50个字符）
    * 验证笔名是否已被使用（isPenNameTaken）
    * 验证地址是否已注册（authors mapping）
    * 验证笔名的UTF-8编码是否有效

    B. 作者信息管理
    - 更新笔名（updatePenName）
    * 验证新笔名的合法性
    * 验证新笔名是否可用
    - 查询作者信息（getAuthor）
    * 显示作者基本信息
    * 显示作者统计数据（作品数、字数、收益等）
    - 查询作者作品列表（getAuthorWorks）
    * 验证作品数量限制（MAX_STORIES_PER_AUTHOR）
    
    作品管理：
    验证每个作者最多100部作品的限制
    验证作品ID与作者的关联关系

2、StoryManager 合约功能验证：
    A. 故事创建和管理
    - 创建新故事（createStory）
    * 验证作者身份
    * 验证故事标题长度和内容
    * 验证分类和标签的合法性
    - 更新故事信息（updateStory）
    * 验证故事所有权
    * 验证更新权限
    - 更新章节（updateChapter）
    * 验证章节内容和标题
    * 验证更新权限

    B. 故事查询功能
    - 获取故事详情（getStory）
    - 获取章节内容（getChapter）
    - 获取故事列表（getStoriesByAuthor）
    - 验证故事状态（连载/完结）

3、NovelNFT 合约功能验证：
    A. NFT 铸造功能
    - 铸造NFT（mint）
    * 验证故事是否存在
    * 验证铸造权限
    * 验证铸造数量限制

    B. NFT 交易功能
    - 转让NFT（transfer）
    - 查询NFT所有权（ownerOf）
    - 查询NFT元数据（tokenURI）

4、TreasuryManager 合约功能验证：
    A. 收益分配功能
    - 分配收益（distributeEarnings）
    * 验证分配比例
    * 验证收益计算

    B. 余额查询
    - 查询可提现余额（getWithdrawableBalance）
    - 查询总收益（getTotalEarnings）

5、MiningPool 合约功能验证：
    A. 挖矿奖励功能
    - 计算挖矿奖励（calculateRewards）
    - 领取挖矿奖励（claimRewards）
    * 验证奖励计算
    * 验证领取条件

    B. 挖矿统计
    - 查询累计奖励（getTotalRewards）
    - 查询可领取奖励（getClaimableRewards）

6、ReaderActivity 合约功能验证：
    A. 读者活动参与
    - 参与活动（participateInActivity）
    * 验证活动有效性
    * 验证参与条件

    B. 活动奖励
    - 领取活动奖励（claimActivityRewards）
    - 查询活动状态（getActivityStatus）

7、TippingSystem 合约功能验证：
    A. 打赏功能
    - 打赏作者（tipAuthor）
    * 验证打赏金额
    * 验证代币余额
    - 打赏故事（tipStory）
    * 验证故事存在性
    * 验证打赏权限

    B. 打赏记录
    - 查询打赏历史（getTippingHistory）
    - 查询收到的打赏（getReceivedTips）

8、代币系统验证 (TaforToken.sol)
    代币管理：
    验证最大供应量限制
    验证铸造权限
    验证转账功能

9、跨合约交互验证：
    A. 权限验证
    - 验证合约间的调用权限
    - 验证角色权限（作者、读者、管理员）
    B. 数据一致性
    - 验证作者信息在各合约中的一致性
    - 验证故事信息在各合约中的一致性
    - 验证NFT与故事的关联关系

9、通用功能验证：
    A. 钱包连接
    - 支持多种钱包（MetaMask、Trust Wallet等）
    - 验证网络切换（BSC主网/测试网）

    B. 交易处理
    - 交易确认和等待
    - 交易失败处理
    - Gas费用估算

    C. 错误处理
    - 合约调用错误处理
    - 用户取消交易处理
    - 网络错误处理

1、先验证基础功能（作者注册、故事创建）
2、再验证核心业务功能（NFT铸造、收益分配）
3、最后验证扩展功能（挖矿、打赏、活动）
4、在每个功能验证时都要考虑正常流程和异常情况
5、特别注意跨合约交互的场景



我现在可以提供一个更全面和准确的验证方案。这个方案将按功能模块进行组织，确保覆盖所有关键功能点：

1、作者管理系统验证 (AuthorManager.sol)
    作者注册功能：
        验证笔名的长度限制(1-50字符)
        验证UTF-8编码的正确性
        验证笔名唯一性
        验证一个地址只能注册一次
    笔名更新功能：
        验证新笔名的有效性
        验证更新过程中的映射关系正确性
    作品管理：
        验证每个作者最多100部作品的限制
        验证作品ID与作者的关联关系
2、故事管理系统验证 (StoryManager.sol)
故事创建功能：
验证标题长度限制
验证描述长度限制
验证目标字数限制
故事更新功能：
验证字数统计的准确性
验证更新权限（只有作者可以更新）
挖矿算力计算：
验证算力计算公式的准确性
验证活跃故事的筛选逻辑
3、NFT系统验证 (NovelNFT.sol)
NFT铸造功能：
验证铸造条件（故事存在且未被放弃）
验证铸造权限
NFT转移功能：
验证转移限制条件
验证转移后的所有权变更
4、打赏系统验证 (TippingSystem.sol)
BNB打赏：
验证打赏金额的分配比例（平台10%，作者45%，NFT持有者45%）
验证作者收益的质押机制（50%质押）
验证BNB转账的成功性
TAFOR代币打赏：
验证代币授权和转账流程
验证分配比例的准确性
验证质押池的正确接收
5、资金管理系统验证 (TreasuryManager.sol)
资金池管理：
验证各资金池的初始化
验证资金池地址设置的权限控制
质押管理：
验证TAFOR质押的记录和释放
验证BNB质押的记录和释放
6、挖矿系统验证 (MiningPool.sol)
奖励分配：
验证周期性分发的触发条件
验证奖励计算公式
验证分配比例（平台10%，抽奖池10%，作者40%，NFT持有者40%）
质押解锁：
验证正常完结的解锁条件
验证放弃作品的惩罚机制
7、读者活动系统验证 (ReaderActivity.sol)
签到系统：
验证签到间隔限制
验证连续签到的记录
抽奖系统：
验证抽奖条件（最少7天活跃）
验证奖励分配机制
验证权重计算的准确性
8、代币系统验证 (TaforToken.sol)
代币管理：
验证最大供应量限制
验证铸造权限
验证转账功能
9、跨合约交互验证
验证合约间的权限设置
验证事件触发的连锁反应
验证数据一致性
安全性验证
重入攻击防护
权限控制
数值计算的溢出保护
10、Gas优化验证
验证批量操作的gas消耗
验证存储优化的效果
对于每个验证点，我们应该：

创建具体的测试用例
设计边界条件测试
模拟异常情况
验证事件触发
检查状态变更





    第二天：作品编辑器功能完善
    // 需要完善的功能
    - 自动保存功能
    - 内容格式验证
    - 编辑器工具栏优化
    第三天：IPFS集成和存储优化
    // 需要实现的功能
    - IPFS上传服务集成
    - 内容加密存储
    - 元数据管理
    第四天：发布流程和阅读功能
    // 需要完善的功能
    - 发布状态管理
    - 阅读权限控制
    - 内容加载优化
    第五天：测试和优化
    // 需要测试的方面
    - 完整流程测试
    - 性能优化
    - 错误处理完善




用户设计：
现在我们的用户系统更加完善了，主要改进包括：

用户类型区分：
READER：普通读者，可以阅读、收藏、评论
AUTHOR：作者，可以发布作品、管理作品
PUBLISHER：出版方，可以管理多个作者和作品
ADMIN：管理员，系统管理权限
渐进式注册流程：
初次连接钱包：自动创建基础用户账户（READER类型）
申请成为作者：补充作者信息，升级为AUTHOR类型
保留原有钱包地址：确保用户身份的连续性
数据模型优化：
添加了用户类型字段
增加了作者验证时间
完善了社交链接存储
添加了统计信息字段
API改进：
支持用户类型升级
处理已存在用户的升级流程
保留用户历史数据


更新数据库和生成新的 Prisma Client
1、在 packages/database 目录下运行：
npx prisma db push

2、然后运行：
npx prisma generate  
如果这个有问题，通过重取客户端也是可以的



创作界面设计方案：

1、本地创作和保存
    作者在本地编辑器中创作内容
    内容实时保存到本地文件系统（apps/web/data/chapters/）
    每个章节包含：
    内容
    标题
    顺序
    字数统计
    创建/更新时间
    状态（草稿/已发布）
2、上传流程 当作者完成创作并决定发布时：
    本地章节 ──┬──> 后台服务器 (存储完整内容)
            ├──> IPFS/分布式存储 (存储完整内容，返回CID)
            └──> 区块链 (存储元数据和IPFS的CID)
    具体步骤：
    先上传到后台服务器
    同时上传到 IPFS，获取 CID
    将元数据和 CID 上链（通过智能合约）
    3、已发布内容管理 需要提供一个界面让作者查看：
    已发布的章节列表
    每个章节的状态：
    本地版本
    服务器版本
    链上版本
    内容比对功能（对比本地和已发布版本的差异）
    更新功能（如果需要修改已发布的内容）
4、数据结构
    typescript

    interface Chapter {
    // 本地数据
    id: string;
    title: string;
    content: string;
    order: number;
    wordCount: number;
    status: 'draft' | 'published';
    createdAt: Date;
    updatedAt: Date;
    
    // 发布后的数据
    publishedData?: {
        serverId: string;      // 后台服务器ID
        ipfsCid: string;       // IPFS CID
        txHash: string;        // 上链交易哈希
        publishedAt: Date;     // 发布时间
        version: number;       // 版本号
    }
    }
5、界面设计 需要有：
    本地章节列表（当前已有）
    发布管理界面，显示：
        章节发布状态
        发布进度
        发布历史
    已发布内容查看界面，显示：
        已发布的章节
        各平台的状态
        更新历史


故事创建及章节创建、上链发布这些环节应该重新好好设计。当前有点乱，我认为应该按照下面对创作界面进行
重新设计作品及章节相关，请把下面的设计进行优化以便你能更好地理解，然后我们再进行代码修改：
1、把作品设置按钮改为作品列表展示按钮，打开时显示自己该作者账户下在连上创建的故事作品。
    在列表展示的末端添加一个增加按钮，点击触发创建新作品弹窗。创建时本地也同样创建一份作品备份。
2、章节显示列表的顶端显示选定作品，下面的章节列表都是基于选定作品的各个章节。
3、所有上面的显示修改都在编辑区的左侧，不要对富文本编辑区进行修改。


存储方案：
1、数据库不存储完整内容，只存储:
    基本元数据(标题、描述等)
    IPFS/Arweave 的 CID
    索引信息
    统计数据
2、内容获取策略:
    列表页只显示基本信息(从数据库)
    详情页按需从 IPFS 获取内容
    可以考虑用 CDN 或缓存层优化访问
3、数据同步:
    链上事件 -> 更新数据库元数据
    不同步存储完整内容
    保持最小必要的索引数据
4、这样可以:
    降低数据库存储成本
    保持去中心化存储的意义
    仍然保证查询性能
    符合行业最佳实践



章节内容当前存储方案：
1、数据库存储完整内容。创作时会把章节内容保存到数据库，作为草稿保存。当进行发布时会把内容上链到IPFS，
并把IPFS的CID和上链的hash保存到数据库。并把数据库中对应的草稿章节转换为已发布状态。
2、链上调用相关章节合约时是不用上传CID的，只需上字数相关。这样的话既能节省链上章节相关的存储成本，
又能更简单实现。每个作品差不多都有百万级别的章节，这些数据还是不少的。
3、如果需要也是可以在合约中添加章节CID map,用于链上保存CID。







主流 Web3 项目的做法：
OpenSea 的做法:
    链上只存储 NFT 的基本信息和所有权
    元数据(metadata)存储在 IPFS
    数据库存储索引和缓存用于快速查询
    但不会完整缓存所有 IPFS 内容，而是按需获取
Mirror 的做法:
    文章内容存储在 Arweave 上
    链上存储文章的 hash 和作者信息
    数据库主要存储索引和基本元数据
    不会缓存全文，而是实时从 Arweave 获取



让我们先梳理一下新的设计：

作品管理改进：
将原来的"作品设置"按钮改为"作品列表"按钮
点击后显示侧边栏，列出该作者的所有作品
列表底部有"新建作品"按钮
创建新作品时同时在链上和本地保存
章节管理改进：
章节列表顶部显示当前选定的作品信息
章节列表只显示当前作品的章节
更清晰的作品-章节层级关系